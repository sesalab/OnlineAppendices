import os
import re
import sys

sys.path.insert(0, "../common")
from commit_analysis import count_commits_between
from git import BadName
from utils import adjust_message, count_all_changes_between, get_file_name

import vccs_extraction

invalid_extensions = ('.txt', '.md', '.man', '.lang', '.loc', '.tex', '.texi', '.rst',
'.gif', '.png', '.jpg', '.jpeg', '.svg', '.ico',
'.css', '.scss', '.less',
'.gradle', '.ini',
'.zip',
'.pdf')
exclusions = r"^(install|changelog(s)?|change(s)?|author(s)?|news|readme|todo|about(s)?|credit(s)?|license|release(s)?|release(s)?|release(_|-)note(s)?|version(s)?|makefile|pom|\.git.*|\.travis|\.classpath|\.project)$"


def is_fix_valid(fix_commit):
    # Do not consider merge fix commits since they have no actual modifications
    if fix_commit.merge:
        print("** Invalid fix commit: it is a merge")
        return False
    # Exclude commits that do not belong to any branch (e.g., subject to rebase)
    if len(fix_commit.branches) == 1 and next(iter(fix_commit.branches)) == '':
        print("** Invalid fix commit: not found in any branch")
        return False
    return True


def is_file_valid(file_path):
    # Extension check
    file_extension = os.path.splitext(file_path)[1]
    if file_extension in invalid_extensions:
        return False
    # Excluded files check
    file_name = os.path.splitext(os.path.basename(file_path))[0]
    if re.match(exclusions, file_name, re.IGNORECASE):
        return False
    # Test files
    file_dir = '/' + os.path.dirname(file_path) + '/'
    directory_match = re.match(r"^.*\/tests?\/.*$", file_dir, re.IGNORECASE)
    prefix_match = re.match(r"^test.+", file_name, re.IGNORECASE)
    postfix_match = re.match(r".+test$", file_name, re.IGNORECASE)
    return not (directory_match or prefix_match or postfix_match)


def enrich_fixes(git_repo, fixes, commits):
    enriched_fixes = []
    for fix in fixes:
        fix_hash = fix["hash"]
        print("* Enriching fix commit {}".format(fix_hash))
        try:
            fix_commit = git_repo.get_commit(fix_hash)
        except (ValueError, BadName):
            print("** Invalid fixing commit: not found in history")
            continue
        if not is_fix_valid(fix_commit):
            continue

        fix_files = []
        fix_added_lines = 0
        fix_removed_lines = 0
        for mod_file in fix_commit.modified_files:
            file_path = get_file_name(mod_file)
            if not is_file_valid(file_path):
                continue
            fix_files.append(file_path)
            fix_added_lines += mod_file.added_lines
            fix_removed_lines += mod_file.deleted_lines

        if len(fix_files) == 0:
            print("** Invalid fixing commit: no relevant files")
            continue        
        if fix_added_lines == 0 and fix_removed_lines == 0:
            print("** Invalid fixing commit: no actual modifications")
            continue

        vccs = vccs_extraction.get_contributing_commits(git_repo, fix_commit, fix_files, commits)
        # If there are no VCCs, we discard it
        if len(vccs) == 0:
            print("** Invalid fixing commit: no contributing commits")
            continue

        enriched_fixes.append({
            "hash": fix_hash,
            "message": adjust_message(fix_commit.msg),
            "date": str(fix_commit.author_date),
            "author": fix_commit.author.email,
            "files": fix_files,
            "added_lines": fix_added_lines,
            "removed_lines": fix_removed_lines,
            "vccs": vccs
        })

    # Before returning, add the number of commits before the last fix commit
    if len(enriched_fixes) > 0:
        last_fix = max(enriched_fixes, key=lambda f: f["date"])
        for enriched_fix in enriched_fixes:
            enriched_fix["commits_before_last_fix"] = count_commits_between(git_repo, enriched_fix["hash"], last_fix["hash"])
            enriched_fix["changes_before_last_fix"] = count_all_changes_between(git_repo, enriched_fix["hash"], last_fix["hash"], enriched_fix["files"])
    return enriched_fixes
