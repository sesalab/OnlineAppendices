from commit_analysis import (count_commits_between, count_previous_changes,
                             get_commit_info, is_useless_line, parse_hunks)
from git.exc import GitCommandError
from pydriller import ModificationType
from utils import count_all_changes_between, get_file_name


def enrich_blamed_commits(git_repo, file_blames, commits, fix_commit):
    blamed_commits = {blame for blames in file_blames.values() for blame in blames}
    enriched_commits = []
    for commit_to_enrich in blamed_commits:
        print("** Enriching the blamed {}".format(commit_to_enrich))
        enriched_commit = get_commit_info(git_repo, commit_to_enrich, commits)
        # It may happen that the blamed commits have no actual modifications, so we discard them
        if enriched_commit["added_lines"] == 0 and enriched_commit["removed_lines"] == 0:
            print("*** Discarded: has no actual modifictions")
            continue
        enriched_commit["commits_before_fix"] = count_commits_between(git_repo, commit_to_enrich, fix_commit.hash)
        
        files = []
        filenames = [f for f, blames in file_blames.items() if commit_to_enrich in blames]
        for filename in filenames:
            files.append({
                "name": filename,
                "changes_before_fix": count_commits_between(git_repo, commit_to_enrich, fix_commit.hash, filename),
                "previous_changes": count_previous_changes(git_repo, commit_to_enrich, fix_commit.hash, filename)
            })
        enriched_commit["files"] = files
        enriched_commit["changes_before_fix"] = count_all_changes_between(git_repo, commit_to_enrich, fix_commit.hash, filenames)
        enriched_commits.append(enriched_commit)
    enriched_commits.sort(reverse=True, key=lambda er: er["date"])
    return enriched_commits


def print_blames(blamed):
    all_blamed_hashes = {blame for blames in blamed.values() for blame in blames}
    print("*** Blamed {} commit(s)".format(len(all_blamed_hashes)))


"""
Get the commits blamed on the deleted lines
"""
def blame_deleted_lines(git_repo, fix_commit, fix_files):
    print("** Blaming the deleted lines...")
    blames = git_repo.get_commits_last_modified_lines(fix_commit)
    blamed_from_deleted_lines = {}
    for file, blamed_hashes in blames.items():
        if file not in fix_files:
            continue
        blamed_from_deleted_lines[file] = blamed_hashes
    print_blames(blamed_from_deleted_lines)
    return blamed_from_deleted_lines


def is_valid_hunk(hunk, modified_file):
    # We are interested in change blocks made of added lines only
    if not all(line.startswith("+") for line in hunk["change_block"]):
        return False

    # If the change block is made ONLY of the following invalid lines, it is invalid for the blame
    first_line_block = int(hunk["new_start_line"]) + len(hunk["before_ctx"])
    last_line_block = first_line_block + len(hunk["change_block"]) - 1
    invalid_lines = []

    ## Step 1: useless lines are invalid
    for index, line in enumerate(hunk["change_block"]):
        if is_useless_line(line[1:].strip()):
            invalid_lines.append(index + first_line_block)
    ## Step 2: if the changed method entirely fits in the changed block, then it is a new method, and its lines are all invalid
    changed_methods = modified_file.changed_methods
    for m in changed_methods:
        if first_line_block <= m.start_line and m.end_line <= last_line_block:
            invalid_lines.extend(range(m.start_line, m.end_line + 1))
    ## Step 3: if a line doesn't belong to any method (constants, global variables, typedefs, etc.), it is invalid
    methods = modified_file.methods
    for i in range(first_line_block, last_line_block + 1):
        inside = False
        for m in methods:
            if m.start_line <= i and i <= m.end_line:
                inside = True
                break
        if not inside:
            invalid_lines.append(i)

    # Remove duplicates and sort
    invalid_lines = sorted(list(set(invalid_lines)))
    if invalid_lines == list(range(first_line_block, last_line_block + 1)):
        return False
    return True


"""
Get the commits blamed on the lines before and after (ignoring the empty lines) the change blocks made of added lines only
"""
def blame_context_lines(git_repo, fix_commit, fix_files):
    print("** Blaming the context lines for add-only hunks...")
    blamed_from_context_lines = {}
    for modified_file in fix_commit.modified_files:
        filepath = get_file_name(modified_file)
        # We don't consider new files because they won't blame anything
        if modified_file.change_type == ModificationType.ADD:
            continue
        # Consider only the files previously appoved
        if not filepath in fix_files:
            continue
        hunks = parse_hunks(modified_file.diff)
        blamed_hashes = set()
        for hunk in hunks:
            # Do not consider invalid hunks
            if not is_valid_hunk(hunk, modified_file):
                continue

            # At this point, we are sure that the hunk is made of added lines only, we can safely consider the "old start line + offset" to blame the entire hunk context only
            start_line = str(hunk["old_start_line"])
            offset = "+" + hunk["old_length"]
            # If the file is not found in the previous commits, it may be due to, rare, double renaming: we ignore these cases
            try:
                blame_output = git_repo.repo.git.blame("-w", "-c", "-l", "-L", start_line + "," + offset, fix_commit.hash + "^", "--", filepath)
            except GitCommandError:
                continue

            blamed_hashes = set()
            for blame_line in blame_output.splitlines():
                blame_line_split = blame_line.split("\t")
                blamed_hash = blame_line_split[0]
                #line_number = blame_line_split[3].split(")")[0]
                code = blame_line_split[3].split(")")[1].strip()
                # Should an empty line be blamed, ignore it
                if not code:
                    continue
                blamed_hashes.add(blamed_hash)
            blamed_from_context_lines[filepath] = blamed_hashes
    print_blames(blamed_from_context_lines)
    return blamed_from_context_lines


def get_contributing_commits(git_repo, fix_commit, fix_files, commits):
    blamed_from_deleted_lines = blame_deleted_lines(git_repo, fix_commit, fix_files)
    blamed_from_context_lines = blame_context_lines(git_repo, fix_commit, fix_files)

    file_blames = blamed_from_deleted_lines.copy()
    for file, item in blamed_from_context_lines.items():
        if file in file_blames:
            file_blames[file].update(item)
        else:
            file_blames[file] = item
    
    blamed_commits = enrich_blamed_commits(git_repo, file_blames, commits, fix_commit)
    return blamed_commits
