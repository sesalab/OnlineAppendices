import datetime as dt
import json
import math
import os
import random
import re
import time

import matplotlib.pyplot as plt
import requests
from git import Repo, exc


def str_to_datetime(date_str):
    return dt.datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S%z")


def rescale_value(distribution, key):
    min_value = min(distribution.values())
    max_value = max(distribution.values())
    if max_value == min_value:
        return 1.0
    else:
        return float(distribution[key] - min_value) / float(max_value - min_value)


def call_api(url, try_number=1):
    try:
        response = requests.get(url, headers={'Accept': 'application/json'}).json()
    except:
        time.sleep(2**try_number + random.random() * 0.01)
        return call_api(url, try_number=try_number + 1)
    else:
        return response


def get_repos(cves):
    repos = []
    for cve in cves:
        for fix in cve["fixes"]:
            repos.append(fix["repo"])
    # Remove duplicates but keep the ordering
    return list(dict.fromkeys(repos))


def get_processed_repos(enriched_repos_filepath, discarded_repos_filepath):
    processed_repos = []
    if os.path.exists(enriched_repos_filepath) and os.path.getsize(enriched_repos_filepath):
        with open(enriched_repos_filepath, 'r') as out_file:
            enriched_repos = json.load(out_file)
    processed_repos = [repo["repo"] for repo in enriched_repos]
    if os.path.exists(discarded_repos_filepath) and os.path.getsize(discarded_repos_filepath):
        with open(discarded_repos_filepath, 'r') as out_file:
            discarded_repos = json.load(out_file)
            processed_repos.extend((repo["repo"] for repo in discarded_repos))
    return processed_repos


def get_processed_cves(enriched_repos_filepath, repo):
    if os.path.exists(enriched_repos_filepath) and os.path.getsize(enriched_repos_filepath):
        with open(enriched_repos_filepath, 'r') as out_file:
            enriched_repos = json.load(out_file)
    for er in enriched_repos:
        if er["repo"] == repo:
            return er["cves"]
    return []


def export_update(new_data, out_filepath):
    data = []
    if os.path.exists(out_filepath) and os.path.getsize(out_filepath):
        with open(out_filepath, 'r') as out_file:
            data = json.load(out_file)
    if new_data["repo"] not in (d["repo"] for d in data):
        data.append(new_data)
    else:
        data = [new_data if d["repo"] == new_data["repo"] else d for d in data]
    with open(out_filepath, 'w') as out_file:
        json.dump(data, out_file, indent=2)
    del data


def is_git_repo(path):
    try:
        _ = Repo(path).git_dir
        return True
    except exc.InvalidGitRepositoryError:
        return False


def get_full_project_name(repo_url):
    org_name = repo_url.rsplit('/', 2)[1]
    project_name = repo_url.rsplit('/', 2)[2]
    return org_name + "_" + project_name


def adjust_message(message):
    message_no_carriage = message.replace("\r", "\n")
    one_newline_message = re.sub(r"\n+", "\n", message_no_carriage)
    clear_message = one_newline_message.replace("\n", ". ").replace("\t", " ").replace(",", " ").replace("\"", "'")
    stripped_message = clear_message.strip()
    return re.sub(r" +", " ", stripped_message)


def get_file_name(file):
    file_path = file.old_path
    # If this happens, then the file has been created in this commit
    if file_path == None:
        file_path = file.new_path
    return file_path

def show_boxplots(df, by, column, label, out_file, log=False):
    # This preserves the order encountered in the dataframe
    max_val = df[column].max()
    min_val = df[column].min()
    cwe_order = df[by].drop_duplicates().tolist()
    _, ax = plt.subplots()
    for pos, col in enumerate(cwe_order):
        reduced_df = df[df[by] == col][column]
        ax.boxplot(reduced_df, showmeans=True, meanline=True, widths=0.25, positions=[pos], labels=[col])
        if (pos + 1) % 5 == 0 or (pos + 1) == len(cwe_order):
            plt.grid(False)
            plt.xlabel(by)
            plt.xticks(rotation=45)
            plt.suptitle("")
            max_val + max_val * 0.1
            ylim_top = max_val + max_val * 0.1
            ylim_bottom = min_val - min_val * 0.1 
            if log:
                plt.ylabel(f"Number of {label} (Log Scale)")
                plt.yscale("log")
                if ylim_top <= 1:
                    ylim_top = 1
                if ylim_bottom <= 1:
                    ylim_bottom = 1
            else:
                plt.ylabel(f"Number of {label}")
                plt.yscale("linear")
            plt.ylim(ylim_bottom, ylim_top)
            plt.savefig(out_file.format(math.ceil((pos + 1) / 5)), bbox_inches="tight")
            plt.clf()
            if (pos + 1) % 5 == 0:
                _, ax = plt.subplots()
    plt.close('all')
